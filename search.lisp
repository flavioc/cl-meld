
(in-package :cl-meld)
   
(defun get-assignments (body) (filter #'assignment-p body))
(defun get-assignment-vars (assignments) (mapcar #'assignment-var assignments))
(defun get-subgoals (code) (filter #'subgoal-p code))
(defun get-comprehensions (code) (filter #'comprehension-p code))
(defun get-agg-constructs (code) (filter #'agg-construct-p code))
(defun get-constraints (code) (remove-if-not #'constraint-p code))

(defun iterate-expr (fn expr)
   (unless expr
      (return-from iterate-expr nil))
   (let ((ls (list)))
      (labels ((aux (expr)
                  (let ((val (funcall fn expr)))
                     (cond
                        ((eq val :stop) (return-from aux))
                        (val
                           (push val ls))))
                  (cond
                     ((clause-p expr)
                        (aux (clause-head expr))
                        (aux (clause-body expr)))
                     ((subgoal-p expr)
								(dolist (arg (subgoal-args expr))
									(aux arg))
								(let ((dest (subgoal-get-remote-dest expr)))
									(when dest
										(aux (make-var dest :type-addr)))))
							((exist-p expr)
								(with-exist expr (:var-list vars :body body)
									(dolist (var vars)
										(aux var))
									(aux body)))
                     ((comprehension-p expr)
                        (with-comprehension expr (:left left :right right)
                           (aux left)
                           (aux right)))
                     ((constraint-p expr) (aux (constraint-expr expr)))
                     ((assignment-p expr)
                        (aux (assignment-var expr))
                        (aux (assignment-expr expr)))
							((agg-construct-p expr)
								(aux (agg-construct-body expr))
								(aux (agg-construct-head expr)))
                     ((if-p expr)
                        (aux (if-cmp expr))
                        (aux (if-e1 expr))
                        (aux (if-e2 expr)))
							((bool-p expr) nil)
                     ((var-p expr) nil)
                     ((int-p expr) nil)
                     ((float-p expr) nil)
                     ((host-id-p expr) nil)
                     ((nil-p expr) nil)
                     ((world-p expr) nil)
                     ((addr-p expr) nil)
                     ((argument-p expr) nil)
							((get-constant-p expr) nil)
							((callf-p expr) (dolist (arg (callf-args expr)) (aux arg)))
							((call-p expr) (dolist (arg (call-args expr)) (aux arg)))
							((struct-p expr)
								(loop for subexpr in (struct-list expr)
									do (aux subexpr)))
							((struct-val-p expr)
								(aux (struct-val-var expr)))
                     ((cons-p expr)
                        (aux (cons-head expr))
                        (aux (cons-tail expr)))
                     ((head-p expr) (aux (head-list expr)))
                     ((tail-p expr) (aux (tail-list expr)))
                     ((not-p expr) (aux (not-expr expr)))
                     ((test-nil-p expr) (aux (test-nil-expr expr)))
                     ((convert-float-p expr) (aux (convert-float-expr expr)))
                     ((let-p expr)
								(aux (let-var expr))
								(aux (let-expr expr))
								(aux (let-body expr)))
							((colocated-p expr)
                        (aux (colocated-first expr))
                        (aux (colocated-second expr)))
                     ((op-p expr)
                        (aux (op-op1 expr))
                        (aux (op-op2 expr)))
                     ((and (listp expr)
                           (not (symbolp (first expr)))
                           (listp (first expr)))
                        (dolist (el expr)
                           (aux el)))
							((null expr) )
                     (t (error 'expr-invalid-error :text (tostring "iterate-expr: Invalid expression: ~a" expr))))))
            (aux expr)
            ls)))
      
(defun all-variables (expr)
   (let ((vars (iterate-expr #'(lambda (x)
                                 (cond
                                    ((var-p x) x))) expr)))
      (remove-duplicates vars :test #'equal)))
      
(defun all-variable-names (expr) (mapcar #'var-name (all-variables expr)))

(defun valid-assignment-p (vars) #'(lambda (a) (tree-subsetp (all-variable-names (assignment-expr a)) vars)))
(defun select-valid-assignments (body subgoals &optional (base-vars nil))
   (loop with vars = (union base-vars (all-variable-names subgoals))
         with ass = (get-assignments body)
         with ret = nil
         for (next-assignments . new-ass) = (split (valid-assignment-p vars) ass)
         while next-assignments
         do (setf ass new-ass)
         do (push-all next-assignments ret)
         do (push-all (mapcar #L(var-name (assignment-var !1)) next-assignments) vars)
         finally (return ret)))

(defun unneeded-assignment-p (body)
   #'(lambda (a)
         (let ((var-name (var-name (assignment-var a)))
               (vars (all-variable-names (remove-tree a body))))
            (not (has-elem-p vars var-name)))))

(defun remove-unneeded-assignments (body &optional head)
   (loop with ass = (get-assignments body)
         for (next-unneeded . next-ass) = (split (unneeded-assignment-p (append body head)) ass)
         while next-unneeded
         do (setf ass next-ass
                  body (remove-all body next-unneeded))
         finally (return body)))

(defmacro find-constraints (body &rest fns)
   `(mapfilter #'constraint-expr #L(and (constraint-p !1)
                                       ,@(loop for fn in fns
                                              collect `(funcall ,fn (constraint-expr !1))))
         ,body))

(defun constraint-by-var1 (var-name expr) (var-eq-p var-name (op-op1 expr)))
(defun constraint-by-var2 (var-name expr) (var-eq-p var-name (op-op2 expr)))

(defun subgoal-by-name (name) #L(string-equal name (subgoal-name !1)))

(defun find-assignment-constraints (body var)
   (find-constraints body
                     #L(equal-p !1)
                     #L(constraint-by-var1 var !1)))

(defun subgoal-appears-code-p (code subgoal-name)
   (do-subgoals code (:name name)
      (when (string-equal name subgoal-name)
         (return-from subgoal-appears-code-p t)))
   nil)
(defun clause-body-matches-subgoal-p (clause subgoal-name)
   (subgoal-appears-code-p (clause-body clause) subgoal-name))
(defun clause-head-matches-subgoal-p (clause subgoal-name)
   (subgoal-appears-code-p (clause-head clause) subgoal-name))
(defun clause-matches-subgoal-p (clause subgoal-name)
   (or (clause-body-matches-subgoal-p clause subgoal-name)
       (clause-head-matches-subgoal-p clause subgoal-name)))
   
(defun subgoal-number-of-occurrences (code subgoal-name)
   (letret (total 0)
      (do-subgoals code (:name name)
         (when (string-equal name subgoal-name)
            (incf total)))))
(defun subgoal-has-var-p (subgoal var)
	(with-subgoal subgoal (:args args)
		(dolist (arg args)
			(when (var-eq-p arg var)
				(return-from subgoal-has-var-p t))))
	nil)
	
(defun subgoals-in-list-have-var-p (ls var)
	(do-subgoals ls (:args args)
		(dolist (arg args)
			(when (var-eq-p arg var)
				(return-from subgoals-in-list-have-var-p t))))
	nil)		
				
(defun clause-body-number-of-occurrences (clause subgoal-name)
   (subgoal-number-of-occurrences (clause-body clause) subgoal-name))
(defun clause-head-number-of-occurrences (clause subgoal-name)
   (subgoal-number-of-occurrences (clause-head clause) subgoal-name))
(defun clause-number-of-occurrences (clause subgoal-name)
   (+ (clause-body-number-of-occurrences clause subgoal-name)
      (clause-head-number-of-occurrences clause subgoal-name)))

(defun is-fact-p (pred-name)
   "Given a predicate name tells you if it is a fact in the program."
   (do-rules (:clause clause)
      (when (clause-head-matches-subgoal-p clause pred-name)
         (return-from is-fact-p nil)))
   t)

(defun find-clauses-with-subgoal-in-body (subgoal-name)
   (filter #'(lambda (clause) (clause-body-matches-subgoal-p clause subgoal-name))
				*clauses*))

